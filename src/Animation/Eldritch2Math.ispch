#include "Eldritch2Types.ispch"

inline Float32 dot( Float2 a, Float2 b )
{
	return( ( a.x * b.x ) +
			( a.y * b.y ) );
}

inline Float32 dot( Float3 a, Float3 b )
{
	return( ( a.x * b.x ) +
			( a.y * b.y ) +
			( a.z * b.z ) );
}

inline Float32 dot( Float4 a, Float4 b )
{
	return( ( a.x * b.x ) +
			( a.y * b.y ) +
			( a.z * b.z ) +
			( a.w * b.w ) );
}

inline Float2 lerp( Float2 a, Float2 b, Float32 alpha )
{
    return (1.f - alpha) * a + alpha * b;
}

inline Float3 lerp( Float3 a, Float3 b, Float32 alpha )
{
    return (1.f - alpha) * a + alpha * b;
}

inline Float4 lerp( Float4 a, Float4 b, Float32 alpha )
{
    return (1.f - alpha) * a + alpha * b;
}

inline Float2 normalize( Float3 vector )
{
	return vector * rsqrt( dot( vector, vector ) );
}

inline Float3 normalize( Float3 vector )
{
	return vector * rsqrt( dot( vector, vector ) );
}

inline Float4 normalize( Float4 vector )
{
	return vector * rsqrt( dot( vector, vector ) );
}

// Adapted from the original by Jonathan Blow, see http://number-none.com/product/Hacking%20Quaternions/index.html
// In particular, the alpha parameter has been changed to take the cosine thereof to exploit the quaternion dot product.
static float32 QuaternionAlphaCorrection( float32	alpha,
										  float32	alphaK,
										  float32	alphaAttenuation,
										  float32	cosAlpha )
{
	const float64	factor( 1.0 - ( alphaAttenuation * cosAlpha ) );
	const float32	k( alphaK * factor * factor );
	const float32	b(  2.0f * k );
	const float32	c( -3.0f * k );
	const float32	d(  1.0f + k );

	return alpha * ( b * alpha + c ) + d;
}

inline Quaternion QuaternionLerp( Quaternion a, Quaternion b, float32 alpha )
{
	return normalize( lerp( a, b, alpha ) );
}

Quaternion ConstantVelocityQuaternionLerp( Quaternion a, Quaternion b, float32 alpha )
{
	// RMS minimized coefficients for the quaternion alpha spline adjustment.
	// Taken from http://number-none.com/product/Hacking%20Quaternions/index.html
	return QuaternionLerp( a, b, QuaternionAlphaCorrection( alpha,
															0.5069269,
															0.7878088,
															dot( a, b ) ) );
}

Quaternion QuaternionMultiply( Quaternion q0, Quaternion q1 )
{
	uniform Quaternion	signFlipMask = { 0x0p0, 0x0p0, 0x0p0, -0x0p0 };

	return ( q0 * q1.wwww ) -
		   ( q0.zxyx * q1.yzxx ) +
		   ( ( q0.yzxz * q1.zxyz ) ^ signFlipMask ) +
		   ( ( q0.wwwy * q1.xyzy ) ^ signFlipMask );
}

inline DualQuaternion DualQuaternionMultiply( DualQuaternion dq, float32 scale )
{
	DualQuaternion result;
	result.real = dq.real * scale;
	result.dual = dq.dual * scale;
	
	return result;
}

inline DualQuaternion DualQuaternionMultiply( DualQuaternion dq0, DualQuaternion dq1 )
{
	DualQuaternion result;
	result.real = QuaternionMultiply( dq0.real, dq1.real );
	result.dual = QuaternionMultiply( dq0.real, dq1.dual ) + QuaternionMultiply( dq0.dual, dq1.real );
	
	return result;
}

Float2 BSpline( Float2 point0, Float2 point1, Float2 point3 )
{
	
}

Float2 HermiteSpline( Float2 point0, Float2 tangent0, Float2 point1, Float2 tangent1, float32 alpha )
{
	// Evaluate the spline using the DeCasteljau method
	Float2 temp = lerp( tangent0, point1, alpha );
	return lerp( lerp( lerp( point0, tangent0, alpha ), temp, alpha ),
				 lerp( temp, lerp( point1, tangent1, alpha ), alpha ), alpha );
}

Float3 HermiteSpline( Float3 point0, Float3 tangent0, Float3 point1, Float3 tangent1, float32 alpha )
{
	// Evaluate the spline using the DeCasteljau method
	Float3 temp = lerp( tangent0, point1, alpha );
	return lerp( lerp( lerp( point0, tangent0, alpha ), temp, alpha ),
				 lerp( temp, lerp( point1, tangent1, alpha ), alpha ), alpha );
}

Float4 HermiteSpline( Float4 point0, Float4 tangent0, Float4 point1, Float4 tangent1, float32 alpha )
{
	// Evaluate the spline using the DeCasteljau method
	Float4 temp = lerp( tangent0, point1, alpha );
	return lerp( lerp( lerp( point0, tangent0, alpha ), temp, alpha ),
				 lerp( temp, lerp( point1, tangent1, alpha ), alpha ), alpha );
}